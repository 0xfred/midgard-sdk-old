"use strict";
/* tslint:disable */
/* eslint-disable */
/**
 * Midgard Public API
 * The Midgard Public API queries THORChain and any chains linked via the BifrÃ¶st and prepares information about the network to be readily available for public users. The API parses transaction event data from THORChain and stores them in a time-series database to make time-dependent queries easy. Midgard does not hold critical information. To interact with BEPSwap and Asgardex, users should query THORChain directly.
 *
 * The version of the OpenAPI document: 2.0.0-alpha.3
 * Contact: devs@thorchain.org
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SpecificationApi = exports.SpecificationApiFactory = exports.SpecificationApiFp = exports.SpecificationApiAxiosParamCreator = exports.DefaultApi = exports.DefaultApiFactory = exports.DefaultApiFp = exports.DefaultApiAxiosParamCreator = exports.ActionTypeEnum = exports.ActionStatusEnum = void 0;
const axios_1 = __importDefault(require("axios"));
// Some imports not used depending on template conditions
// @ts-ignore
const base_1 = require("./base");
const url_1 = require("url");
/**
 * @export
 * @enum {string}
 */
var ActionStatusEnum;
(function (ActionStatusEnum) {
    ActionStatusEnum["Success"] = "success";
    ActionStatusEnum["Pending"] = "pending";
})(ActionStatusEnum = exports.ActionStatusEnum || (exports.ActionStatusEnum = {}));
/**
 * @export
 * @enum {string}
 */
var ActionTypeEnum;
(function (ActionTypeEnum) {
    ActionTypeEnum["Swap"] = "swap";
    ActionTypeEnum["AddLiquidity"] = "addLiquidity";
    ActionTypeEnum["Withdraw"] = "withdraw";
    ActionTypeEnum["Donate"] = "donate";
    ActionTypeEnum["Refund"] = "refund";
})(ActionTypeEnum = exports.ActionTypeEnum || (exports.ActionTypeEnum = {}));
/**
 * DefaultApi - axios parameter creator
 * @export
 */
const DefaultApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * List actions along with their related transactions. An action is generated by one or more inbound transactions with the intended action set in the transaction memo. The action may result in one or more outbound transactions. Results are paginated by sets of 50. Filters may be applied to query actions.
         * @summary Actions List
         * @param {number} limit pagination limit
         * @param {number} offset pagination offset
         * @param {string} [address] Address of sender or recipient of any in/out transaction related to the action
         * @param {string} [txid] ID of any in/out tx related to the action
         * @param {string} [asset] Any asset that is part of the action (CHAIN.SYMBOL)
         * @param {string} [type] One or more comma separated unique types of action (swap, addLiquidity, withdraw, donate, refund)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActions: (limit, offset, address, txid, asset, type, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'limit' is not null or undefined
            if (limit === null || limit === undefined) {
                throw new base_1.RequiredError('limit', 'Required parameter limit was null or undefined when calling getActions.');
            }
            // verify required parameter 'offset' is not null or undefined
            if (offset === null || offset === undefined) {
                throw new base_1.RequiredError('offset', 'Required parameter offset was null or undefined when calling getActions.');
            }
            const localVarPath = `/v2/actions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new url_1.URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }
            if (txid !== undefined) {
                localVarQueryParameter['txid'] = txid;
            }
            if (asset !== undefined) {
                localVarQueryParameter['asset'] = asset;
            }
            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            const queryParameters = new url_1.URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = new url_1.URLSearchParams(queryParameters).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns the asset and rune depths and price. The values report the state at the end of each interval.  History endpoint has two modes: * With Interval parameter it returns a series of time buckets. From and To dates will   be rounded to the Interval boundaries. * Without Interval parameter a single From..To search is performed with exact timestamps.   * Interval: possible values: 5min, hour, day, week, month, quarter, year. * count: [1..100]. Defines number of intervals. Don\'t provide if Interval is missing. * from/to: optional int, unix second.  Possible usages with interval. * last 10 days: `?interval=day&count=10` * last 10 days before to: `?interval=day&count=10&to=1608825600` * next 10 days after from: `?interval=day&count=10&from=1606780800` * Days between from and to. From defaults to start of chain, to defaults to now.   Only the first 100 intervals are returned:   `interval=day&from=1606780800&to=1608825600`  Pagination is possible with from&count and then using the returned meta.endTime as the From parameter of the next query.  Possible configurations without interval: * exact search for one time frame: `?from=1606780899&to=1608825600` * one time frame until now: `?from=1606780899` * from chain start until now: no query parameters
         * @summary Depth and Price History
         * @param {string} pool Return stats for this single pool.
         * @param {'5min' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year'} [interval] Interval of calculations
         * @param {number} [count] Number of intervals to return. Should be between [1..100].
         * @param {number} [to] End time of the query as unix timestamp. If only count is given, defaults to now.
         * @param {number} [from] Start time of the query as unix timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDepthHistory: (pool, interval, count, to, from, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'pool' is not null or undefined
            if (pool === null || pool === undefined) {
                throw new base_1.RequiredError('pool', 'Required parameter pool was null or undefined when calling getDepthHistory.');
            }
            const localVarPath = `/v2/history/depths/{pool}`.replace(`{${'pool'}}`, encodeURIComponent(String(pool)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new url_1.URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }
            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }
            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }
            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }
            const queryParameters = new url_1.URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = new url_1.URLSearchParams(queryParameters).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns earnings data for the specified interval.  History endpoint has two modes: * With Interval parameter it returns a series of time buckets. From and To dates will   be rounded to the Interval boundaries. * Without Interval parameter a single From..To search is performed with exact timestamps.   * Interval: possible values: 5min, hour, day, week, month, quarter, year. * count: [1..100]. Defines number of intervals. Don\'t provide if Interval is missing. * from/to: optional int, unix second.  Possible usages with interval. * last 10 days: `?interval=day&count=10` * last 10 days before to: `?interval=day&count=10&to=1608825600` * next 10 days after from: `?interval=day&count=10&from=1606780800` * Days between from and to. From defaults to start of chain, to defaults to now.   Only the first 100 intervals are returned:   `interval=day&from=1606780800&to=1608825600`  Pagination is possible with from&count and then using the returned meta.endTime as the From parameter of the next query.  Possible configurations without interval: * exact search for one time frame: `?from=1606780899&to=1608825600` * one time frame until now: `?from=1606780899` * from chain start until now: no query parameters
         * @summary Earnings History
         * @param {'5min' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year'} [interval] Interval of calculations
         * @param {number} [count] Number of intervals to return. Should be between [1..100].
         * @param {number} [to] End time of the query as unix timestamp. If only count is given, defaults to now.
         * @param {number} [from] Start time of the query as unix timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEarningsHistory: (interval, count, to, from, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v2/history/earnings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new url_1.URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }
            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }
            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }
            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }
            const queryParameters = new url_1.URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = new url_1.URLSearchParams(queryParameters).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns an object containing the health response of the API
         * @summary Health Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHealth: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v2/health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new url_1.URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const queryParameters = new url_1.URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = new url_1.URLSearchParams(queryParameters).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns withdrawals and deposits for given time interval. If pool is not specified returns for all pools  History endpoint has two modes: * With Interval parameter it returns a series of time buckets. From and To dates will   be rounded to the Interval boundaries. * Without Interval parameter a single From..To search is performed with exact timestamps.   * Interval: possible values: 5min, hour, day, week, month, quarter, year. * count: [1..100]. Defines number of intervals. Don\'t provide if Interval is missing. * from/to: optional int, unix second.  Possible usages with interval. * last 10 days: `?interval=day&count=10` * last 10 days before to: `?interval=day&count=10&to=1608825600` * next 10 days after from: `?interval=day&count=10&from=1606780800` * Days between from and to. From defaults to start of chain, to defaults to now.   Only the first 100 intervals are returned:   `interval=day&from=1606780800&to=1608825600`  Pagination is possible with from&count and then using the returned meta.endTime as the From parameter of the next query.  Possible configurations without interval: * exact search for one time frame: `?from=1606780899&to=1608825600` * one time frame until now: `?from=1606780899` * from chain start until now: no query parameters
         * @summary Liquidity Changes History
         * @param {string} [pool] Return stats for given pool. Returns sum of all pools if missing
         * @param {'5min' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year'} [interval] Interval of calculations
         * @param {number} [count] Number of intervals to return. Should be between [1..100]
         * @param {number} [to] End time of the query as unix timestamp. If only count is given, defaults to now
         * @param {number} [from] Start time of the query as unix timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLiquidityHistory: (pool, interval, count, to, from, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v2/history/liquidity_changes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new url_1.URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (pool !== undefined) {
                localVarQueryParameter['pool'] = pool;
            }
            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }
            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }
            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }
            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }
            const queryParameters = new url_1.URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = new url_1.URLSearchParams(queryParameters).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns an array of statistics for all the liquidity providers associated with a given member address.
         * @summary Member Details
         * @param {string} address Address to match liquidity providers. Either a rune or an asset address may be given.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMemberDetail: (address, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'address' is not null or undefined
            if (address === null || address === undefined) {
                throw new base_1.RequiredError('address', 'Required parameter address was null or undefined when calling getMemberDetail.');
            }
            const localVarPath = `/v2/member/{address}`.replace(`{${'address'}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new url_1.URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const queryParameters = new url_1.URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = new url_1.URLSearchParams(queryParameters).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns an array containing the addresses for all pool members. Addresses are only shown once. If there\'s both a RUNE address and an asset address for a member, only the RUNE address will be shown.
         * @summary Members List
         * @param {string} [pool] Return only members present in the pool.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMembersAdresses: (pool, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v2/members`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new url_1.URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (pool !== undefined) {
                localVarQueryParameter['pool'] = pool;
            }
            const queryParameters = new url_1.URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = new url_1.URLSearchParams(queryParameters).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns an object containing Network data
         * @summary Network Data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNetworkData: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v2/network`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new url_1.URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const queryParameters = new url_1.URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = new url_1.URLSearchParams(queryParameters).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns a list of Node public keys and adresses.
         * @summary Nodes List
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNodes: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v2/nodes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new url_1.URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const queryParameters = new url_1.URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = new url_1.URLSearchParams(queryParameters).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns details of the pool: depths, price, 24h volume, APY.
         * @summary Details of a Pool
         * @param {string} asset pool name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPool: (asset, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'asset' is not null or undefined
            if (asset === null || asset === undefined) {
                throw new base_1.RequiredError('asset', 'Required parameter asset was null or undefined when calling getPool.');
            }
            const localVarPath = `/v2/pool/{asset}`.replace(`{${'asset'}}`, encodeURIComponent(String(asset)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new url_1.URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const queryParameters = new url_1.URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = new url_1.URLSearchParams(queryParameters).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         * Statistics about the pool. The description of the fields have pointers about the corresponding v2/history location. Visit the history endpoint for drilldowns.
         * @summary Pool Statistics
         * @param {string} asset pool name
         * @param {'1h' | '24h' | '7d' | '30d' | '90d' | '365d' | 'all'} [period] Restricts aggregation type fields to the last period only. Default is 30d.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPoolStats: (asset, period, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'asset' is not null or undefined
            if (asset === null || asset === undefined) {
                throw new base_1.RequiredError('asset', 'Required parameter asset was null or undefined when calling getPoolStats.');
            }
            const localVarPath = `/v2/pool/{asset}/stats`.replace(`{${'asset'}}`, encodeURIComponent(String(asset)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new url_1.URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (period !== undefined) {
                localVarQueryParameter['period'] = period;
            }
            const queryParameters = new url_1.URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = new url_1.URLSearchParams(queryParameters).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         * Legacy, V1 style names for backward compatibility. Please migrate to GetPoolStats, check the fields documentation for details.
         * @summary Pool Statistics (v1 naming)
         * @param {string} asset pool name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPoolStatsLegacy: (asset, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'asset' is not null or undefined
            if (asset === null || asset === undefined) {
                throw new base_1.RequiredError('asset', 'Required parameter asset was null or undefined when calling getPoolStatsLegacy.');
            }
            const localVarPath = `/v2/pool/{asset}/stats/legacy`.replace(`{${'asset'}}`, encodeURIComponent(String(asset)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new url_1.URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const queryParameters = new url_1.URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = new url_1.URLSearchParams(queryParameters).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns an array containing details for a set of pools
         * @summary Pools List
         * @param {'available' | 'staged' | 'suspended'} [status] Filter for only pools with this status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPools: (status, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v2/pools`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new url_1.URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }
            const queryParameters = new url_1.URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = new url_1.URLSearchParams(queryParameters).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         * Constant values used by THORChain , some of the values can be overrided by mimir
         * @summary Proxied THORChain Constants
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProxiedConstants: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v2/thorchain/constants`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new url_1.URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const queryParameters = new url_1.URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = new url_1.URLSearchParams(queryParameters).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         * Inbound addresses will return a list of address , one per chain. The address might change frequently if THORChain has multiple asgards.
         * @summary Proxied THORChain Inbound Addresses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProxiedInboundAddresses: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v2/thorchain/inbound_addresses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new url_1.URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const queryParameters = new url_1.URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = new url_1.URLSearchParams(queryParameters).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         * Retrieve lastest block infomation across all chains.
         * @summary Proxied THORChain Lastblock
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProxiedLastblock: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v2/thorchain/lastblock`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new url_1.URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const queryParameters = new url_1.URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = new url_1.URLSearchParams(queryParameters).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns the proxied queue endpoint from a local thornode
         * @summary Proxied THORChain Queue
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProxiedQueue: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v2/thorchain/queue`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new url_1.URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const queryParameters = new url_1.URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = new url_1.URLSearchParams(queryParameters).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns an object containing global stats for all pools and all transactions
         * @summary Global Stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStats: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v2/stats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new url_1.URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const queryParameters = new url_1.URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = new url_1.URLSearchParams(queryParameters).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns swap count, volume, fees, slip in specified interval. If pool is not specified returns for all pools  History endpoint has two modes: * With Interval parameter it returns a series of time buckets. From and To dates will   be rounded to the Interval boundaries. * Without Interval parameter a single From..To search is performed with exact timestamps.   * Interval: possible values: 5min, hour, day, week, month, quarter, year. * count: [1..100]. Defines number of intervals. Don\'t provide if Interval is missing. * from/to: optional int, unix second.  Possible usages with interval. * last 10 days: `?interval=day&count=10` * last 10 days before to: `?interval=day&count=10&to=1608825600` * next 10 days after from: `?interval=day&count=10&from=1606780800` * Days between from and to. From defaults to start of chain, to defaults to now.   Only the first 100 intervals are returned:   `interval=day&from=1606780800&to=1608825600`  Pagination is possible with from&count and then using the returned meta.endTime as the From parameter of the next query.  Possible configurations without interval: * exact search for one time frame: `?from=1606780899&to=1608825600` * one time frame until now: `?from=1606780899` * from chain start until now: no query parameters
         * @summary Swaps History
         * @param {string} [pool] Return history given pool. Returns sum of all pools if missing.
         * @param {'5min' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year'} [interval] Interval of calculations
         * @param {number} [count] Number of intervals to return. Should be between [1..100].
         * @param {number} [to] End time of the query as unix timestamp. If only count is given, defaults to now.
         * @param {number} [from] Start time of the query as unix timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSwapHistory: (pool, interval, count, to, from, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v2/history/swaps`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new url_1.URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (pool !== undefined) {
                localVarQueryParameter['pool'] = pool;
            }
            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }
            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }
            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }
            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }
            const queryParameters = new url_1.URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = new url_1.URLSearchParams(queryParameters).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.DefaultApiAxiosParamCreator = DefaultApiAxiosParamCreator;
/**
 * DefaultApi - functional programming interface
 * @export
 */
const DefaultApiFp = function (configuration) {
    return {
        /**
         * List actions along with their related transactions. An action is generated by one or more inbound transactions with the intended action set in the transaction memo. The action may result in one or more outbound transactions. Results are paginated by sets of 50. Filters may be applied to query actions.
         * @summary Actions List
         * @param {number} limit pagination limit
         * @param {number} offset pagination offset
         * @param {string} [address] Address of sender or recipient of any in/out transaction related to the action
         * @param {string} [txid] ID of any in/out tx related to the action
         * @param {string} [asset] Any asset that is part of the action (CHAIN.SYMBOL)
         * @param {string} [type] One or more comma separated unique types of action (swap, addLiquidity, withdraw, donate, refund)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActions(limit, offset, address, txid, asset, type, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.DefaultApiAxiosParamCreator(configuration).getActions(limit, offset, address, txid, asset, type, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Returns the asset and rune depths and price. The values report the state at the end of each interval.  History endpoint has two modes: * With Interval parameter it returns a series of time buckets. From and To dates will   be rounded to the Interval boundaries. * Without Interval parameter a single From..To search is performed with exact timestamps.   * Interval: possible values: 5min, hour, day, week, month, quarter, year. * count: [1..100]. Defines number of intervals. Don\'t provide if Interval is missing. * from/to: optional int, unix second.  Possible usages with interval. * last 10 days: `?interval=day&count=10` * last 10 days before to: `?interval=day&count=10&to=1608825600` * next 10 days after from: `?interval=day&count=10&from=1606780800` * Days between from and to. From defaults to start of chain, to defaults to now.   Only the first 100 intervals are returned:   `interval=day&from=1606780800&to=1608825600`  Pagination is possible with from&count and then using the returned meta.endTime as the From parameter of the next query.  Possible configurations without interval: * exact search for one time frame: `?from=1606780899&to=1608825600` * one time frame until now: `?from=1606780899` * from chain start until now: no query parameters
         * @summary Depth and Price History
         * @param {string} pool Return stats for this single pool.
         * @param {'5min' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year'} [interval] Interval of calculations
         * @param {number} [count] Number of intervals to return. Should be between [1..100].
         * @param {number} [to] End time of the query as unix timestamp. If only count is given, defaults to now.
         * @param {number} [from] Start time of the query as unix timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDepthHistory(pool, interval, count, to, from, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.DefaultApiAxiosParamCreator(configuration).getDepthHistory(pool, interval, count, to, from, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Returns earnings data for the specified interval.  History endpoint has two modes: * With Interval parameter it returns a series of time buckets. From and To dates will   be rounded to the Interval boundaries. * Without Interval parameter a single From..To search is performed with exact timestamps.   * Interval: possible values: 5min, hour, day, week, month, quarter, year. * count: [1..100]. Defines number of intervals. Don\'t provide if Interval is missing. * from/to: optional int, unix second.  Possible usages with interval. * last 10 days: `?interval=day&count=10` * last 10 days before to: `?interval=day&count=10&to=1608825600` * next 10 days after from: `?interval=day&count=10&from=1606780800` * Days between from and to. From defaults to start of chain, to defaults to now.   Only the first 100 intervals are returned:   `interval=day&from=1606780800&to=1608825600`  Pagination is possible with from&count and then using the returned meta.endTime as the From parameter of the next query.  Possible configurations without interval: * exact search for one time frame: `?from=1606780899&to=1608825600` * one time frame until now: `?from=1606780899` * from chain start until now: no query parameters
         * @summary Earnings History
         * @param {'5min' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year'} [interval] Interval of calculations
         * @param {number} [count] Number of intervals to return. Should be between [1..100].
         * @param {number} [to] End time of the query as unix timestamp. If only count is given, defaults to now.
         * @param {number} [from] Start time of the query as unix timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEarningsHistory(interval, count, to, from, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.DefaultApiAxiosParamCreator(configuration).getEarningsHistory(interval, count, to, from, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Returns an object containing the health response of the API
         * @summary Health Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHealth(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.DefaultApiAxiosParamCreator(configuration).getHealth(options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Returns withdrawals and deposits for given time interval. If pool is not specified returns for all pools  History endpoint has two modes: * With Interval parameter it returns a series of time buckets. From and To dates will   be rounded to the Interval boundaries. * Without Interval parameter a single From..To search is performed with exact timestamps.   * Interval: possible values: 5min, hour, day, week, month, quarter, year. * count: [1..100]. Defines number of intervals. Don\'t provide if Interval is missing. * from/to: optional int, unix second.  Possible usages with interval. * last 10 days: `?interval=day&count=10` * last 10 days before to: `?interval=day&count=10&to=1608825600` * next 10 days after from: `?interval=day&count=10&from=1606780800` * Days between from and to. From defaults to start of chain, to defaults to now.   Only the first 100 intervals are returned:   `interval=day&from=1606780800&to=1608825600`  Pagination is possible with from&count and then using the returned meta.endTime as the From parameter of the next query.  Possible configurations without interval: * exact search for one time frame: `?from=1606780899&to=1608825600` * one time frame until now: `?from=1606780899` * from chain start until now: no query parameters
         * @summary Liquidity Changes History
         * @param {string} [pool] Return stats for given pool. Returns sum of all pools if missing
         * @param {'5min' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year'} [interval] Interval of calculations
         * @param {number} [count] Number of intervals to return. Should be between [1..100]
         * @param {number} [to] End time of the query as unix timestamp. If only count is given, defaults to now
         * @param {number} [from] Start time of the query as unix timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLiquidityHistory(pool, interval, count, to, from, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.DefaultApiAxiosParamCreator(configuration).getLiquidityHistory(pool, interval, count, to, from, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Returns an array of statistics for all the liquidity providers associated with a given member address.
         * @summary Member Details
         * @param {string} address Address to match liquidity providers. Either a rune or an asset address may be given.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMemberDetail(address, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.DefaultApiAxiosParamCreator(configuration).getMemberDetail(address, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Returns an array containing the addresses for all pool members. Addresses are only shown once. If there\'s both a RUNE address and an asset address for a member, only the RUNE address will be shown.
         * @summary Members List
         * @param {string} [pool] Return only members present in the pool.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMembersAdresses(pool, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.DefaultApiAxiosParamCreator(configuration).getMembersAdresses(pool, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Returns an object containing Network data
         * @summary Network Data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNetworkData(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.DefaultApiAxiosParamCreator(configuration).getNetworkData(options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Returns a list of Node public keys and adresses.
         * @summary Nodes List
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNodes(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.DefaultApiAxiosParamCreator(configuration).getNodes(options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Returns details of the pool: depths, price, 24h volume, APY.
         * @summary Details of a Pool
         * @param {string} asset pool name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPool(asset, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.DefaultApiAxiosParamCreator(configuration).getPool(asset, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Statistics about the pool. The description of the fields have pointers about the corresponding v2/history location. Visit the history endpoint for drilldowns.
         * @summary Pool Statistics
         * @param {string} asset pool name
         * @param {'1h' | '24h' | '7d' | '30d' | '90d' | '365d' | 'all'} [period] Restricts aggregation type fields to the last period only. Default is 30d.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPoolStats(asset, period, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.DefaultApiAxiosParamCreator(configuration).getPoolStats(asset, period, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Legacy, V1 style names for backward compatibility. Please migrate to GetPoolStats, check the fields documentation for details.
         * @summary Pool Statistics (v1 naming)
         * @param {string} asset pool name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPoolStatsLegacy(asset, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.DefaultApiAxiosParamCreator(configuration).getPoolStatsLegacy(asset, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Returns an array containing details for a set of pools
         * @summary Pools List
         * @param {'available' | 'staged' | 'suspended'} [status] Filter for only pools with this status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPools(status, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.DefaultApiAxiosParamCreator(configuration).getPools(status, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Constant values used by THORChain , some of the values can be overrided by mimir
         * @summary Proxied THORChain Constants
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProxiedConstants(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.DefaultApiAxiosParamCreator(configuration).getProxiedConstants(options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Inbound addresses will return a list of address , one per chain. The address might change frequently if THORChain has multiple asgards.
         * @summary Proxied THORChain Inbound Addresses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProxiedInboundAddresses(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.DefaultApiAxiosParamCreator(configuration).getProxiedInboundAddresses(options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Retrieve lastest block infomation across all chains.
         * @summary Proxied THORChain Lastblock
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProxiedLastblock(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.DefaultApiAxiosParamCreator(configuration).getProxiedLastblock(options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Returns the proxied queue endpoint from a local thornode
         * @summary Proxied THORChain Queue
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProxiedQueue(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.DefaultApiAxiosParamCreator(configuration).getProxiedQueue(options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Returns an object containing global stats for all pools and all transactions
         * @summary Global Stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStats(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.DefaultApiAxiosParamCreator(configuration).getStats(options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Returns swap count, volume, fees, slip in specified interval. If pool is not specified returns for all pools  History endpoint has two modes: * With Interval parameter it returns a series of time buckets. From and To dates will   be rounded to the Interval boundaries. * Without Interval parameter a single From..To search is performed with exact timestamps.   * Interval: possible values: 5min, hour, day, week, month, quarter, year. * count: [1..100]. Defines number of intervals. Don\'t provide if Interval is missing. * from/to: optional int, unix second.  Possible usages with interval. * last 10 days: `?interval=day&count=10` * last 10 days before to: `?interval=day&count=10&to=1608825600` * next 10 days after from: `?interval=day&count=10&from=1606780800` * Days between from and to. From defaults to start of chain, to defaults to now.   Only the first 100 intervals are returned:   `interval=day&from=1606780800&to=1608825600`  Pagination is possible with from&count and then using the returned meta.endTime as the From parameter of the next query.  Possible configurations without interval: * exact search for one time frame: `?from=1606780899&to=1608825600` * one time frame until now: `?from=1606780899` * from chain start until now: no query parameters
         * @summary Swaps History
         * @param {string} [pool] Return history given pool. Returns sum of all pools if missing.
         * @param {'5min' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year'} [interval] Interval of calculations
         * @param {number} [count] Number of intervals to return. Should be between [1..100].
         * @param {number} [to] End time of the query as unix timestamp. If only count is given, defaults to now.
         * @param {number} [from] Start time of the query as unix timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSwapHistory(pool, interval, count, to, from, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.DefaultApiAxiosParamCreator(configuration).getSwapHistory(pool, interval, count, to, from, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
exports.DefaultApiFp = DefaultApiFp;
/**
 * DefaultApi - factory interface
 * @export
 */
const DefaultApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * List actions along with their related transactions. An action is generated by one or more inbound transactions with the intended action set in the transaction memo. The action may result in one or more outbound transactions. Results are paginated by sets of 50. Filters may be applied to query actions.
         * @summary Actions List
         * @param {number} limit pagination limit
         * @param {number} offset pagination offset
         * @param {string} [address] Address of sender or recipient of any in/out transaction related to the action
         * @param {string} [txid] ID of any in/out tx related to the action
         * @param {string} [asset] Any asset that is part of the action (CHAIN.SYMBOL)
         * @param {string} [type] One or more comma separated unique types of action (swap, addLiquidity, withdraw, donate, refund)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActions(limit, offset, address, txid, asset, type, options) {
            return exports.DefaultApiFp(configuration)
                .getActions(limit, offset, address, txid, asset, type, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Returns the asset and rune depths and price. The values report the state at the end of each interval.  History endpoint has two modes: * With Interval parameter it returns a series of time buckets. From and To dates will   be rounded to the Interval boundaries. * Without Interval parameter a single From..To search is performed with exact timestamps.   * Interval: possible values: 5min, hour, day, week, month, quarter, year. * count: [1..100]. Defines number of intervals. Don\'t provide if Interval is missing. * from/to: optional int, unix second.  Possible usages with interval. * last 10 days: `?interval=day&count=10` * last 10 days before to: `?interval=day&count=10&to=1608825600` * next 10 days after from: `?interval=day&count=10&from=1606780800` * Days between from and to. From defaults to start of chain, to defaults to now.   Only the first 100 intervals are returned:   `interval=day&from=1606780800&to=1608825600`  Pagination is possible with from&count and then using the returned meta.endTime as the From parameter of the next query.  Possible configurations without interval: * exact search for one time frame: `?from=1606780899&to=1608825600` * one time frame until now: `?from=1606780899` * from chain start until now: no query parameters
         * @summary Depth and Price History
         * @param {string} pool Return stats for this single pool.
         * @param {'5min' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year'} [interval] Interval of calculations
         * @param {number} [count] Number of intervals to return. Should be between [1..100].
         * @param {number} [to] End time of the query as unix timestamp. If only count is given, defaults to now.
         * @param {number} [from] Start time of the query as unix timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDepthHistory(pool, interval, count, to, from, options) {
            return exports.DefaultApiFp(configuration)
                .getDepthHistory(pool, interval, count, to, from, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Returns earnings data for the specified interval.  History endpoint has two modes: * With Interval parameter it returns a series of time buckets. From and To dates will   be rounded to the Interval boundaries. * Without Interval parameter a single From..To search is performed with exact timestamps.   * Interval: possible values: 5min, hour, day, week, month, quarter, year. * count: [1..100]. Defines number of intervals. Don\'t provide if Interval is missing. * from/to: optional int, unix second.  Possible usages with interval. * last 10 days: `?interval=day&count=10` * last 10 days before to: `?interval=day&count=10&to=1608825600` * next 10 days after from: `?interval=day&count=10&from=1606780800` * Days between from and to. From defaults to start of chain, to defaults to now.   Only the first 100 intervals are returned:   `interval=day&from=1606780800&to=1608825600`  Pagination is possible with from&count and then using the returned meta.endTime as the From parameter of the next query.  Possible configurations without interval: * exact search for one time frame: `?from=1606780899&to=1608825600` * one time frame until now: `?from=1606780899` * from chain start until now: no query parameters
         * @summary Earnings History
         * @param {'5min' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year'} [interval] Interval of calculations
         * @param {number} [count] Number of intervals to return. Should be between [1..100].
         * @param {number} [to] End time of the query as unix timestamp. If only count is given, defaults to now.
         * @param {number} [from] Start time of the query as unix timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEarningsHistory(interval, count, to, from, options) {
            return exports.DefaultApiFp(configuration)
                .getEarningsHistory(interval, count, to, from, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Returns an object containing the health response of the API
         * @summary Health Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHealth(options) {
            return exports.DefaultApiFp(configuration)
                .getHealth(options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Returns withdrawals and deposits for given time interval. If pool is not specified returns for all pools  History endpoint has two modes: * With Interval parameter it returns a series of time buckets. From and To dates will   be rounded to the Interval boundaries. * Without Interval parameter a single From..To search is performed with exact timestamps.   * Interval: possible values: 5min, hour, day, week, month, quarter, year. * count: [1..100]. Defines number of intervals. Don\'t provide if Interval is missing. * from/to: optional int, unix second.  Possible usages with interval. * last 10 days: `?interval=day&count=10` * last 10 days before to: `?interval=day&count=10&to=1608825600` * next 10 days after from: `?interval=day&count=10&from=1606780800` * Days between from and to. From defaults to start of chain, to defaults to now.   Only the first 100 intervals are returned:   `interval=day&from=1606780800&to=1608825600`  Pagination is possible with from&count and then using the returned meta.endTime as the From parameter of the next query.  Possible configurations without interval: * exact search for one time frame: `?from=1606780899&to=1608825600` * one time frame until now: `?from=1606780899` * from chain start until now: no query parameters
         * @summary Liquidity Changes History
         * @param {string} [pool] Return stats for given pool. Returns sum of all pools if missing
         * @param {'5min' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year'} [interval] Interval of calculations
         * @param {number} [count] Number of intervals to return. Should be between [1..100]
         * @param {number} [to] End time of the query as unix timestamp. If only count is given, defaults to now
         * @param {number} [from] Start time of the query as unix timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLiquidityHistory(pool, interval, count, to, from, options) {
            return exports.DefaultApiFp(configuration)
                .getLiquidityHistory(pool, interval, count, to, from, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of statistics for all the liquidity providers associated with a given member address.
         * @summary Member Details
         * @param {string} address Address to match liquidity providers. Either a rune or an asset address may be given.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMemberDetail(address, options) {
            return exports.DefaultApiFp(configuration)
                .getMemberDetail(address, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Returns an array containing the addresses for all pool members. Addresses are only shown once. If there\'s both a RUNE address and an asset address for a member, only the RUNE address will be shown.
         * @summary Members List
         * @param {string} [pool] Return only members present in the pool.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMembersAdresses(pool, options) {
            return exports.DefaultApiFp(configuration)
                .getMembersAdresses(pool, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Returns an object containing Network data
         * @summary Network Data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNetworkData(options) {
            return exports.DefaultApiFp(configuration)
                .getNetworkData(options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of Node public keys and adresses.
         * @summary Nodes List
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNodes(options) {
            return exports.DefaultApiFp(configuration)
                .getNodes(options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Returns details of the pool: depths, price, 24h volume, APY.
         * @summary Details of a Pool
         * @param {string} asset pool name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPool(asset, options) {
            return exports.DefaultApiFp(configuration)
                .getPool(asset, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Statistics about the pool. The description of the fields have pointers about the corresponding v2/history location. Visit the history endpoint for drilldowns.
         * @summary Pool Statistics
         * @param {string} asset pool name
         * @param {'1h' | '24h' | '7d' | '30d' | '90d' | '365d' | 'all'} [period] Restricts aggregation type fields to the last period only. Default is 30d.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPoolStats(asset, period, options) {
            return exports.DefaultApiFp(configuration)
                .getPoolStats(asset, period, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Legacy, V1 style names for backward compatibility. Please migrate to GetPoolStats, check the fields documentation for details.
         * @summary Pool Statistics (v1 naming)
         * @param {string} asset pool name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPoolStatsLegacy(asset, options) {
            return exports.DefaultApiFp(configuration)
                .getPoolStatsLegacy(asset, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Returns an array containing details for a set of pools
         * @summary Pools List
         * @param {'available' | 'staged' | 'suspended'} [status] Filter for only pools with this status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPools(status, options) {
            return exports.DefaultApiFp(configuration)
                .getPools(status, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Constant values used by THORChain , some of the values can be overrided by mimir
         * @summary Proxied THORChain Constants
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProxiedConstants(options) {
            return exports.DefaultApiFp(configuration)
                .getProxiedConstants(options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Inbound addresses will return a list of address , one per chain. The address might change frequently if THORChain has multiple asgards.
         * @summary Proxied THORChain Inbound Addresses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProxiedInboundAddresses(options) {
            return exports.DefaultApiFp(configuration)
                .getProxiedInboundAddresses(options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Retrieve lastest block infomation across all chains.
         * @summary Proxied THORChain Lastblock
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProxiedLastblock(options) {
            return exports.DefaultApiFp(configuration)
                .getProxiedLastblock(options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Returns the proxied queue endpoint from a local thornode
         * @summary Proxied THORChain Queue
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProxiedQueue(options) {
            return exports.DefaultApiFp(configuration)
                .getProxiedQueue(options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Returns an object containing global stats for all pools and all transactions
         * @summary Global Stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStats(options) {
            return exports.DefaultApiFp(configuration)
                .getStats(options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Returns swap count, volume, fees, slip in specified interval. If pool is not specified returns for all pools  History endpoint has two modes: * With Interval parameter it returns a series of time buckets. From and To dates will   be rounded to the Interval boundaries. * Without Interval parameter a single From..To search is performed with exact timestamps.   * Interval: possible values: 5min, hour, day, week, month, quarter, year. * count: [1..100]. Defines number of intervals. Don\'t provide if Interval is missing. * from/to: optional int, unix second.  Possible usages with interval. * last 10 days: `?interval=day&count=10` * last 10 days before to: `?interval=day&count=10&to=1608825600` * next 10 days after from: `?interval=day&count=10&from=1606780800` * Days between from and to. From defaults to start of chain, to defaults to now.   Only the first 100 intervals are returned:   `interval=day&from=1606780800&to=1608825600`  Pagination is possible with from&count and then using the returned meta.endTime as the From parameter of the next query.  Possible configurations without interval: * exact search for one time frame: `?from=1606780899&to=1608825600` * one time frame until now: `?from=1606780899` * from chain start until now: no query parameters
         * @summary Swaps History
         * @param {string} [pool] Return history given pool. Returns sum of all pools if missing.
         * @param {'5min' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year'} [interval] Interval of calculations
         * @param {number} [count] Number of intervals to return. Should be between [1..100].
         * @param {number} [to] End time of the query as unix timestamp. If only count is given, defaults to now.
         * @param {number} [from] Start time of the query as unix timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSwapHistory(pool, interval, count, to, from, options) {
            return exports.DefaultApiFp(configuration)
                .getSwapHistory(pool, interval, count, to, from, options)
                .then((request) => request(axios, basePath));
        },
    };
};
exports.DefaultApiFactory = DefaultApiFactory;
/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
class DefaultApi extends base_1.BaseAPI {
    /**
     * List actions along with their related transactions. An action is generated by one or more inbound transactions with the intended action set in the transaction memo. The action may result in one or more outbound transactions. Results are paginated by sets of 50. Filters may be applied to query actions.
     * @summary Actions List
     * @param {number} limit pagination limit
     * @param {number} offset pagination offset
     * @param {string} [address] Address of sender or recipient of any in/out transaction related to the action
     * @param {string} [txid] ID of any in/out tx related to the action
     * @param {string} [asset] Any asset that is part of the action (CHAIN.SYMBOL)
     * @param {string} [type] One or more comma separated unique types of action (swap, addLiquidity, withdraw, donate, refund)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    getActions(limit, offset, address, txid, asset, type, options) {
        return exports.DefaultApiFp(this.configuration)
            .getActions(limit, offset, address, txid, asset, type, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the asset and rune depths and price. The values report the state at the end of each interval.  History endpoint has two modes: * With Interval parameter it returns a series of time buckets. From and To dates will   be rounded to the Interval boundaries. * Without Interval parameter a single From..To search is performed with exact timestamps.   * Interval: possible values: 5min, hour, day, week, month, quarter, year. * count: [1..100]. Defines number of intervals. Don\'t provide if Interval is missing. * from/to: optional int, unix second.  Possible usages with interval. * last 10 days: `?interval=day&count=10` * last 10 days before to: `?interval=day&count=10&to=1608825600` * next 10 days after from: `?interval=day&count=10&from=1606780800` * Days between from and to. From defaults to start of chain, to defaults to now.   Only the first 100 intervals are returned:   `interval=day&from=1606780800&to=1608825600`  Pagination is possible with from&count and then using the returned meta.endTime as the From parameter of the next query.  Possible configurations without interval: * exact search for one time frame: `?from=1606780899&to=1608825600` * one time frame until now: `?from=1606780899` * from chain start until now: no query parameters
     * @summary Depth and Price History
     * @param {string} pool Return stats for this single pool.
     * @param {'5min' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year'} [interval] Interval of calculations
     * @param {number} [count] Number of intervals to return. Should be between [1..100].
     * @param {number} [to] End time of the query as unix timestamp. If only count is given, defaults to now.
     * @param {number} [from] Start time of the query as unix timestamp
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    getDepthHistory(pool, interval, count, to, from, options) {
        return exports.DefaultApiFp(this.configuration)
            .getDepthHistory(pool, interval, count, to, from, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns earnings data for the specified interval.  History endpoint has two modes: * With Interval parameter it returns a series of time buckets. From and To dates will   be rounded to the Interval boundaries. * Without Interval parameter a single From..To search is performed with exact timestamps.   * Interval: possible values: 5min, hour, day, week, month, quarter, year. * count: [1..100]. Defines number of intervals. Don\'t provide if Interval is missing. * from/to: optional int, unix second.  Possible usages with interval. * last 10 days: `?interval=day&count=10` * last 10 days before to: `?interval=day&count=10&to=1608825600` * next 10 days after from: `?interval=day&count=10&from=1606780800` * Days between from and to. From defaults to start of chain, to defaults to now.   Only the first 100 intervals are returned:   `interval=day&from=1606780800&to=1608825600`  Pagination is possible with from&count and then using the returned meta.endTime as the From parameter of the next query.  Possible configurations without interval: * exact search for one time frame: `?from=1606780899&to=1608825600` * one time frame until now: `?from=1606780899` * from chain start until now: no query parameters
     * @summary Earnings History
     * @param {'5min' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year'} [interval] Interval of calculations
     * @param {number} [count] Number of intervals to return. Should be between [1..100].
     * @param {number} [to] End time of the query as unix timestamp. If only count is given, defaults to now.
     * @param {number} [from] Start time of the query as unix timestamp
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    getEarningsHistory(interval, count, to, from, options) {
        return exports.DefaultApiFp(this.configuration)
            .getEarningsHistory(interval, count, to, from, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns an object containing the health response of the API
     * @summary Health Info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    getHealth(options) {
        return exports.DefaultApiFp(this.configuration)
            .getHealth(options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns withdrawals and deposits for given time interval. If pool is not specified returns for all pools  History endpoint has two modes: * With Interval parameter it returns a series of time buckets. From and To dates will   be rounded to the Interval boundaries. * Without Interval parameter a single From..To search is performed with exact timestamps.   * Interval: possible values: 5min, hour, day, week, month, quarter, year. * count: [1..100]. Defines number of intervals. Don\'t provide if Interval is missing. * from/to: optional int, unix second.  Possible usages with interval. * last 10 days: `?interval=day&count=10` * last 10 days before to: `?interval=day&count=10&to=1608825600` * next 10 days after from: `?interval=day&count=10&from=1606780800` * Days between from and to. From defaults to start of chain, to defaults to now.   Only the first 100 intervals are returned:   `interval=day&from=1606780800&to=1608825600`  Pagination is possible with from&count and then using the returned meta.endTime as the From parameter of the next query.  Possible configurations without interval: * exact search for one time frame: `?from=1606780899&to=1608825600` * one time frame until now: `?from=1606780899` * from chain start until now: no query parameters
     * @summary Liquidity Changes History
     * @param {string} [pool] Return stats for given pool. Returns sum of all pools if missing
     * @param {'5min' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year'} [interval] Interval of calculations
     * @param {number} [count] Number of intervals to return. Should be between [1..100]
     * @param {number} [to] End time of the query as unix timestamp. If only count is given, defaults to now
     * @param {number} [from] Start time of the query as unix timestamp
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    getLiquidityHistory(pool, interval, count, to, from, options) {
        return exports.DefaultApiFp(this.configuration)
            .getLiquidityHistory(pool, interval, count, to, from, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns an array of statistics for all the liquidity providers associated with a given member address.
     * @summary Member Details
     * @param {string} address Address to match liquidity providers. Either a rune or an asset address may be given.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    getMemberDetail(address, options) {
        return exports.DefaultApiFp(this.configuration)
            .getMemberDetail(address, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns an array containing the addresses for all pool members. Addresses are only shown once. If there\'s both a RUNE address and an asset address for a member, only the RUNE address will be shown.
     * @summary Members List
     * @param {string} [pool] Return only members present in the pool.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    getMembersAdresses(pool, options) {
        return exports.DefaultApiFp(this.configuration)
            .getMembersAdresses(pool, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns an object containing Network data
     * @summary Network Data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    getNetworkData(options) {
        return exports.DefaultApiFp(this.configuration)
            .getNetworkData(options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns a list of Node public keys and adresses.
     * @summary Nodes List
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    getNodes(options) {
        return exports.DefaultApiFp(this.configuration)
            .getNodes(options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns details of the pool: depths, price, 24h volume, APY.
     * @summary Details of a Pool
     * @param {string} asset pool name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    getPool(asset, options) {
        return exports.DefaultApiFp(this.configuration)
            .getPool(asset, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Statistics about the pool. The description of the fields have pointers about the corresponding v2/history location. Visit the history endpoint for drilldowns.
     * @summary Pool Statistics
     * @param {string} asset pool name
     * @param {'1h' | '24h' | '7d' | '30d' | '90d' | '365d' | 'all'} [period] Restricts aggregation type fields to the last period only. Default is 30d.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    getPoolStats(asset, period, options) {
        return exports.DefaultApiFp(this.configuration)
            .getPoolStats(asset, period, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Legacy, V1 style names for backward compatibility. Please migrate to GetPoolStats, check the fields documentation for details.
     * @summary Pool Statistics (v1 naming)
     * @param {string} asset pool name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    getPoolStatsLegacy(asset, options) {
        return exports.DefaultApiFp(this.configuration)
            .getPoolStatsLegacy(asset, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns an array containing details for a set of pools
     * @summary Pools List
     * @param {'available' | 'staged' | 'suspended'} [status] Filter for only pools with this status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    getPools(status, options) {
        return exports.DefaultApiFp(this.configuration)
            .getPools(status, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Constant values used by THORChain , some of the values can be overrided by mimir
     * @summary Proxied THORChain Constants
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    getProxiedConstants(options) {
        return exports.DefaultApiFp(this.configuration)
            .getProxiedConstants(options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Inbound addresses will return a list of address , one per chain. The address might change frequently if THORChain has multiple asgards.
     * @summary Proxied THORChain Inbound Addresses
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    getProxiedInboundAddresses(options) {
        return exports.DefaultApiFp(this.configuration)
            .getProxiedInboundAddresses(options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve lastest block infomation across all chains.
     * @summary Proxied THORChain Lastblock
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    getProxiedLastblock(options) {
        return exports.DefaultApiFp(this.configuration)
            .getProxiedLastblock(options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the proxied queue endpoint from a local thornode
     * @summary Proxied THORChain Queue
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    getProxiedQueue(options) {
        return exports.DefaultApiFp(this.configuration)
            .getProxiedQueue(options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns an object containing global stats for all pools and all transactions
     * @summary Global Stats
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    getStats(options) {
        return exports.DefaultApiFp(this.configuration)
            .getStats(options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns swap count, volume, fees, slip in specified interval. If pool is not specified returns for all pools  History endpoint has two modes: * With Interval parameter it returns a series of time buckets. From and To dates will   be rounded to the Interval boundaries. * Without Interval parameter a single From..To search is performed with exact timestamps.   * Interval: possible values: 5min, hour, day, week, month, quarter, year. * count: [1..100]. Defines number of intervals. Don\'t provide if Interval is missing. * from/to: optional int, unix second.  Possible usages with interval. * last 10 days: `?interval=day&count=10` * last 10 days before to: `?interval=day&count=10&to=1608825600` * next 10 days after from: `?interval=day&count=10&from=1606780800` * Days between from and to. From defaults to start of chain, to defaults to now.   Only the first 100 intervals are returned:   `interval=day&from=1606780800&to=1608825600`  Pagination is possible with from&count and then using the returned meta.endTime as the From parameter of the next query.  Possible configurations without interval: * exact search for one time frame: `?from=1606780899&to=1608825600` * one time frame until now: `?from=1606780899` * from chain start until now: no query parameters
     * @summary Swaps History
     * @param {string} [pool] Return history given pool. Returns sum of all pools if missing.
     * @param {'5min' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year'} [interval] Interval of calculations
     * @param {number} [count] Number of intervals to return. Should be between [1..100].
     * @param {number} [to] End time of the query as unix timestamp. If only count is given, defaults to now.
     * @param {number} [from] Start time of the query as unix timestamp
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    getSwapHistory(pool, interval, count, to, from, options) {
        return exports.DefaultApiFp(this.configuration)
            .getSwapHistory(pool, interval, count, to, from, options)
            .then((request) => request(this.axios, this.basePath));
    }
}
exports.DefaultApi = DefaultApi;
/**
 * SpecificationApi - axios parameter creator
 * @export
 */
const SpecificationApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Swagger/OpenAPI 3.0 specification generated documents.
         * @summary Documentation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocs: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v2/doc`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new url_1.URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const queryParameters = new url_1.URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = new url_1.URLSearchParams(queryParameters).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns human and machine readable swagger/openapi specification
         * @summary Swagger File
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSwagger: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v2/swagger.json`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new url_1.URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const queryParameters = new url_1.URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = new url_1.URLSearchParams(queryParameters).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.SpecificationApiAxiosParamCreator = SpecificationApiAxiosParamCreator;
/**
 * SpecificationApi - functional programming interface
 * @export
 */
const SpecificationApiFp = function (configuration) {
    return {
        /**
         * Swagger/OpenAPI 3.0 specification generated documents.
         * @summary Documentation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocs(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.SpecificationApiAxiosParamCreator(configuration).getDocs(options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Returns human and machine readable swagger/openapi specification
         * @summary Swagger File
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSwagger(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.SpecificationApiAxiosParamCreator(configuration).getSwagger(options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
exports.SpecificationApiFp = SpecificationApiFp;
/**
 * SpecificationApi - factory interface
 * @export
 */
const SpecificationApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Swagger/OpenAPI 3.0 specification generated documents.
         * @summary Documentation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocs(options) {
            return exports.SpecificationApiFp(configuration)
                .getDocs(options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Returns human and machine readable swagger/openapi specification
         * @summary Swagger File
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSwagger(options) {
            return exports.SpecificationApiFp(configuration)
                .getSwagger(options)
                .then((request) => request(axios, basePath));
        },
    };
};
exports.SpecificationApiFactory = SpecificationApiFactory;
/**
 * SpecificationApi - object-oriented interface
 * @export
 * @class SpecificationApi
 * @extends {BaseAPI}
 */
class SpecificationApi extends base_1.BaseAPI {
    /**
     * Swagger/OpenAPI 3.0 specification generated documents.
     * @summary Documentation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpecificationApi
     */
    getDocs(options) {
        return exports.SpecificationApiFp(this.configuration)
            .getDocs(options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns human and machine readable swagger/openapi specification
     * @summary Swagger File
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpecificationApi
     */
    getSwagger(options) {
        return exports.SpecificationApiFp(this.configuration)
            .getSwagger(options)
            .then((request) => request(this.axios, this.basePath));
    }
}
exports.SpecificationApi = SpecificationApi;
//# sourceMappingURL=api.js.map